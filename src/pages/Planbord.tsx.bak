import { useState, useMemo, useCallback, useRef, useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Badge } from '@/components/ui/badge';
import { Switch } from '@/components/ui/switch';
import { Label } from '@/components/ui/label';
import { Separator } from '@/components/ui/separator';
import { Tooltip, TooltipContent, TooltipTrigger } from '@/components/ui/tooltip';
import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';
import { Command, CommandEmpty, CommandGroup, CommandInput, CommandItem } from '@/components/ui/command';
import {
  Lock,
  Unlock,
  Trash2,
  AlertTriangle,
  ChevronLeft,
  ChevronRight,
  X,
  PackageCheck,
  PackageX,
  RotateCcw,
  Wand2,
  Sparkles,
  PackageMinus,
  Table as TableIcon,
  LayoutGrid,
  Check,
  ChevronsUpDown,
} from 'lucide-react';
import {
  schedulerOrders as initialOrders,
  machines,
  machineGroups,
  getSetupTime,
  type SchedulerOrder,
  type ProductType,
} from '@/data/mockData';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';
import { Sheet, SheetContent, SheetHeader, SheetTitle } from '@/components/ui/sheet';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import { Checkbox } from '@/components/ui/checkbox';

const statusColors: Record<string, string> = {
  planned: 'bg-primary',
  locked: 'bg-status-ok',
  'near-deadline': 'bg-status-warning',
  late: 'bg-status-danger',
};

const statusLabels: Record<string, string> = {
  planned: 'Gepland',
  locked: 'Vergrendeld',
  'near-deadline': 'Bijna deadline',
  late: 'Te laat',
};

interface SetupBlock {
  id: string;
  machine: string;
  startHour: number;
  durationHours: number;
  fromType: ProductType;
  toType: ProductType;
  setupHours: number;
}

// Helper to format date from hour offset
function formatDate(baseDate: Date, hourOffset: number): string {
  const d = new Date(baseDate);
  d.setTime(d.getTime() + hourOffset * 60 * 60 * 1000);
  return d.toLocaleDateString('nl-NL', { day: '2-digit', month: '2-digit' });
}

// Helper to format hour as day + time
function formatHourLabel(hourOffset: number): string {
  const days = Math.floor(hourOffset / 24);
  const hours = hourOffset % 24;
  return `D${days} ${hours.toString().padStart(2, '0')}:00`;
}

export default function Scheduler() {
  // State management
  const [orders, setOrders] = useState<SchedulerOrder[]>(initialOrders);
  const [selectedOrder, setSelectedOrder] = useState<SchedulerOrder | null>(null);
  const [showLateOnly, setShowLateOnly] = useState(false);
  const [filterGroup, setFilterGroup] = useState<string>('all');
  const [filterMachine, setFilterMachine] = useState<string>('all-machines');
  const [filterOrderNumber, setFilterOrderNumber] = useState<string>('');
  const [viewMode, setViewMode] = useState<'gantt' | 'table'>('gantt');
  const [drawerOrder, setDrawerOrder] = useState<SchedulerOrder | null>(null);
  const [draggedOrder, setDraggedOrder] = useState<SchedulerOrder | null>(null);
  const [dragOffset, setDragOffset] = useState<number>(0);
  const [dragPreviewHour, setDragPreviewHour] = useState<number | null>(null);
  const [dragPreviewMachine, setDragPreviewMachine] = useState<string | null>(null);
  const timelineRef = useRef<HTMLDivElement>(null);
  const ganttChartRef = useRef<HTMLDivElement>(null);

  // Purge all dialog state
  const [purgeAllDialogOpen, setPurgeAllDialogOpen] = useState(false);
  const [purgeStartDate, setPurgeStartDate] = useState<string>(''); // ISO date string
  const [purgeStartTime, setPurgeStartTime] = useState<string>('00:00');
  const [purgeEndDate, setPurgeEndDate] = useState<string>(''); // ISO date string
  const [purgeEndTime, setPurgeEndTime] = useState<string>('23:59');
  const [selectedMachines, setSelectedMachines] = useState<string[]>([]);

  // Date range configuration (in hours)
  const [startDate, setStartDate] = useState(new Date(2026, 1, 16)); // Feb 16, 2026
  const [hoursToShow, setHoursToShow] = useState(42 * 24); // 6 weeks default in hours
  
  // Initialize purge dialog dates when opened
  useEffect(() => {
    if (purgeAllDialogOpen && !purgeStartDate) {
      const start = new Date(startDate);
      const end = new Date(startDate);
      end.setDate(end.getDate() + Math.floor(hoursToShow / 24));
      
      setPurgeStartDate(start.toISOString().split('T')[0]);
      setPurgeEndDate(end.toISOString().split('T')[0]);
    }
  }, [purgeAllDialogOpen, startDate, hoursToShow, purgeStartDate]);
  
  // Convert date/time to hour offset from startDate
  const dateTimeToHours = (dateStr: string, timeStr: string): number => {
    const [year, month, day] = dateStr.split('-').map(Number);
    const [hours, minutes] = timeStr.split(':').map(Number);
    const targetDate = new Date(year, month - 1, day, hours, minutes);
    const diffMs = targetDate.getTime() - startDate.getTime();
    return Math.floor(diffMs / (1000 * 60 * 60));
  };

  // Multi-select for machine groups
  const [selectedGroups, setSelectedGroups] = useState<string[]>([]);
  
  // Navigation handlers
  const today = useMemo(() => new Date(2026, 1, 16), []); // Current date in the mockup
  
  const handleNavigateBackward = useCallback(() => {
    setStartDate((prev) => {
      const newDate = new Date(prev);
      newDate.setDate(newDate.getDate() - Math.floor(hoursToShow / 24));
      // Don't go before today
      return newDate < today ? today : newDate;
    });
  }, [hoursToShow, today]);
  
  const handleNavigateForward = useCallback(() => {
    setStartDate((prev) => {
      const newDate = new Date(prev);
      newDate.setDate(newDate.getDate() + Math.floor(hoursToShow / 24));
      return newDate;
    });
  }, [hoursToShow]);
  
  const canNavigateBackward = useMemo(() => {
    const prevDate = new Date(startDate);
    prevDate.setDate(prevDate.getDate() - Math.floor(hoursToShow / 24));
    return prevDate >= today;
  }, [startDate, hoursToShow, today]);

  // CTRL+scroll zoom handler
  const handleWheel = useCallback((e: WheelEvent) => {
    e.preventDefault();
    const zoomFactor = e.deltaY > 0 ? 1.1 : 0.9;
    setHoursToShow((prev) => {
      const newHours = Math.round(prev * zoomFactor);
      // Limit between 1 day and 16 weeks
      return Math.max(24, Math.min(16 * 7 * 24, newHours));
    });
  }, []);

  // Attach wheel event listener for zoom
  useEffect(() => {
    const ganttElement = ganttChartRef.current;
    if (ganttElement) {
      ganttElement.addEventListener('wheel', handleWheel as any, { passive: false });
      return () => ganttElement.removeEventListener('wheel', handleWheel as any);
    }
  }, [handleWheel]);

  // Calculate setup blocks based on order sequence per machine
  const setupBlocks = useMemo<SetupBlock[]>(() => {
    const blocks: SetupBlock[] = [];
    const machineOrderMap = new Map<string, SchedulerOrder[]>();

    orders.forEach((order) => {
      if (!machineOrderMap.has(order.machine)) {
        machineOrderMap.set(order.machine, []);
      }
      machineOrderMap.get(order.machine)!.push(order);
    });

    machineOrderMap.forEach((machineOrders, machine) => {
      const sorted = machineOrders.sort((a, b) => a.startHour - b.startHour);

      for (let i = 1; i < sorted.length; i++) {
        const prevOrder = sorted[i - 1];
        const currOrder = sorted[i];

        if (prevOrder.productType !== currOrder.productType) {
          const setupHours = getSetupTime(prevOrder.productType, currOrder.productType);
          const setupStartHour = prevOrder.startHour + prevOrder.durationHours;

          blocks.push({
            id: `setup-${prevOrder.id}-${currOrder.id}`,
            machine,
            startHour: setupStartHour,
            durationHours: setupHours,
            fromType: prevOrder.productType,
            toType: currOrder.productType,
            setupHours,
          });
        }
      }
    });

    return blocks;
  }, [orders]);

  // Generate timeline columns (show in day increments, but track hours internally)
  // When zoomed to 3 days or less, switch to hourly view
  const timelineColumns = useMemo(() => {
    const showHourly = hoursToShow <= 72; // 3 days or less
    
    if (showHourly) {
      // Generate hourly columns
      const hoursToDisplay = Math.ceil(hoursToShow);
      return Array.from({ length: hoursToDisplay }, (_, i) => {
        const d = new Date(startDate);
        d.setHours(d.getHours() + i);
        const isWeekend = d.getDay() === 0 || d.getDay() === 6;
        
        return {
          label: `${d.getHours().toString().padStart(2, '0')}:00`,
          dateLabel: `${d.getDate()}/${d.getMonth() + 1}`,
          date: new Date(d.getFullYear(), d.getMonth(), d.getDate()), // Date without time for grouping
          dayIndex: Math.floor(i / 24),
          hourOffset: i,
          isWeekend,
          isHourly: true,
        };
      });
    } else {
      // Generate daily columns (original behavior)
      const daysToShow = Math.ceil(hoursToShow / 24);
      return Array.from({ length: daysToShow }, (_, i) => {
        const d = new Date(startDate);
        d.setDate(d.getDate() + i);
        return {
          label: `${d.getDate()}/${d.getMonth() + 1}`,
          dateLabel: '',
          date: new Date(d.getFullYear(), d.getMonth(), d.getDate()),
          dayIndex: i,
          hourOffset: i * 24,
          isWeekend: d.getDay() === 0 || d.getDay() === 6,
          isHourly: false,
        };
      });
    }
  }, [startDate, hoursToShow]);
  
  // Group timeline columns by date (for hourly view)
  const timelineGroups = useMemo(() => {
    if (!timelineColumns[0]?.isHourly) return [];
    
    const groups: Array<{
      dateLabel: string;
      date: Date;
      columns: typeof timelineColumns;
      isWeekend: boolean;
    }> = [];
    
    timelineColumns.forEach((col) => {
      const lastGroup = groups[groups.length - 1];
      const colDateStr = col.date.toISOString().split('T')[0];
      const lastDateStr = lastGroup?.date.toISOString().split('T')[0];
      
      if (!lastGroup || colDateStr !== lastDateStr) {
        groups.push({
          dateLabel: col.dateLabel,
          date: col.date,
          columns: [col],
          isWeekend: col.isWeekend,
        });
      } else {
        lastGroup.columns.push(col);
      }
    });
    
    return groups;
  }, [timelineColumns]);

  // Apply filters and only show orders within visible timerange
  const filteredOrders = useMemo(() => {
    let filtered = orders.filter((o) => {
      // Filter out orders completely outside visible range
      const orderEndHour = o.startHour + o.durationHours;
      return o.startHour < hoursToShow && orderEndHour > 0;
    });

    if (showLateOnly) {
      filtered = filtered.filter((o) => o.status === 'late' || o.status === 'near-deadline');
    }

    // Multi-select group filter
    if (selectedGroups.length > 0) {
      filtered = filtered.filter((o) => selectedGroups.includes(o.machineGroup.toLowerCase()));
    }

    if (filterMachine !== 'all-machines') {
      filtered = filtered.filter((o) => o.machine.toLowerCase().replace(/\s/g, '-') === filterMachine);
    }

    if (filterOrderNumber) {
      filtered = filtered.filter((o) => o.orderNumber.toLowerCase().includes(filterOrderNumber.toLowerCase()));
    }

    return filtered;
  }, [orders, showLateOnly, selectedGroups, filterMachine, filterOrderNumber, hoursToShow]);

  // Get filtered machines (only show machines from selected groups)
  const filteredMachines = useMemo(() => {
    return machines.filter((machine) => {
      // Filter by selected groups (multi-select)
      if (selectedGroups.length > 0 && !selectedGroups.includes(machine.groupId)) {
        return false;
      }
      if (filterMachine !== 'all-machines' && machine.name.toLowerCase().replace(/\s/g, '-') !== filterMachine) {
        return false;
      }
      return orders.some((o) => o.machine === machine.name);
    });
  }, [selectedGroups, filterMachine, orders]);

  // Get available machines for machine filter dropdown (based on selected groups)
  const availableMachinesForFilter = useMemo(() => {
    if (selectedGroups.length === 0) {
      return machines;
    }
    return machines.filter((m) => selectedGroups.includes(m.groupId));
  }, [selectedGroups]);

  // Get orders that belong to the same parent order as selected
  const orderFlow = useMemo(() => {
    if (!selectedOrder || !selectedOrder.parentOrderNumber) return [];
    return orders.filter((o) => o.parentOrderNumber === selectedOrder.parentOrderNumber);
  }, [selectedOrder, orders]);

  // Lock/unlock order
  const handleToggleLock = useCallback(
    (order: SchedulerOrder) => {
      setOrders((prev) =>
        prev.map((o) =>
          o.id === order.id ? { ...o, status: o.status === 'locked' ? 'planned' : 'locked' } : o
        )
      );
      if (selectedOrder?.id === order.id) {
        setSelectedOrder((prev) =>
          prev ? { ...prev, status: prev.status === 'locked' ? 'planned' : 'locked' } : null
        );
      }
    },
    [selectedOrder]
  );

  // Delete order
  const handleDeleteOrder = useCallback(
    (order: SchedulerOrder) => {
      setOrders((prev) => prev.filter((o) => o.id !== order.id));
      if (selectedOrder?.id === order.id) {
        setSelectedOrder(null);
      }
      if (drawerOrder?.id === order.id) {
        setDrawerOrder(null);
      }
    },
    [selectedOrder, drawerOrder]
  );

  // Move order back or forward (by 8 hours = 1 work day)
  const handleMoveOrder = useCallback(
    (order: SchedulerOrder, direction: 'back' | 'forward') => {
      const shift = direction === 'back' ? -8 : 8;
      setOrders((prev) =>
        prev.map((o) => (o.id === order.id ? { ...o, startHour: Math.max(0, o.startHour + shift) } : o))
      );
      if (selectedOrder?.id === order.id) {
        setSelectedOrder((prev) => (prev ? { ...prev, startHour: Math.max(0, prev.startHour + shift) } : null));
      }
    },
    [selectedOrder]
  );

  // Purge single order (move as close as possible to previous order)
  const handlePurgeOrder = useCallback((order: SchedulerOrder) => {
    setOrders((prev) => {
      const machineOrders = prev
        .filter((o) => o.machine === order.machine)
        .sort((a, b) => a.startHour - b.startHour);

      const orderIndex = machineOrders.findIndex((o) => o.id === order.id);
      if (orderIndex <= 0) return prev; // Already first or not found

      const prevOrder = machineOrders[orderIndex - 1];
      let newStartHour = prevOrder.startHour + prevOrder.durationHours;

      // Check if setup time is needed
      if (prevOrder.productType !== order.productType) {
        const setupHours = getSetupTime(prevOrder.productType, order.productType);
        newStartHour += setupHours;
      }

      return prev.map((o) => (o.id === order.id ? { ...o, startHour: newStartHour } : o));
    });
  }, []);

  // Purge all orders in selected machines within timeframe
  const handlePurgeAll = useCallback(() => {
    const purgeStartHour = dateTimeToHours(purgeStartDate, purgeStartTime);
    const purgeEndHour = dateTimeToHours(purgeEndDate, purgeEndTime);
    
    setOrders((prev) => {
      const newOrders = [...prev];

      selectedMachines.forEach((machineName) => {
        const machineOrders = newOrders
          .filter(
            (o) =>
              o.machine === machineName &&
              o.startHour >= purgeStartHour &&
              o.startHour <= purgeEndHour &&
              o.status !== 'locked'
          )
          .sort((a, b) => a.startHour - b.startHour);

        let currentHour = purgeStartHour;
        let lastProductType: ProductType | null = null;

        // Find last order before timeframe to get last product type
        const beforeOrders = newOrders
          .filter((o) => o.machine === machineName && o.startHour < purgeStartHour)
          .sort((a, b) => b.startHour - a.startHour);

        if (beforeOrders.length > 0) {
          currentHour = beforeOrders[0].startHour + beforeOrders[0].durationHours;
          lastProductType = beforeOrders[0].productType;
        }

        machineOrders.forEach((order) => {
          // Add setup time if needed
          if (lastProductType && lastProductType !== order.productType) {
            const setupHours = getSetupTime(lastProductType, order.productType);
            currentHour += setupHours;
          }

          const orderInArray = newOrders.find((o) => o.id === order.id);
          if (orderInArray) {
            orderInArray.startHour = currentHour;
            currentHour += order.durationHours;
            lastProductType = order.productType;
          }
        });
      });

      return newOrders;
    });

    setPurgeAllDialogOpen(false);
    setSelectedMachines([]);
  }, [selectedMachines, purgeStartDate, purgeStartTime, purgeEndDate, purgeEndTime, dateTimeToHours]);

  // Auto-plan algorithm
  const handleAutoPlan = useCallback(() => {
    setOrders((prev) => {
      // Group orders by parent order number to maintain flow
      const orderGroups = new Map<string, SchedulerOrder[]>();
      prev.forEach((order) => {
        const parent = order.parentOrderNumber || order.orderNumber;
        if (!orderGroups.has(parent)) {
          orderGroups.set(parent, []);
        }
        orderGroups.get(parent)!.push(order);
      });

      // Parse deadlines and sort by deadline
      const sortedGroups = Array.from(orderGroups.entries())
        .map(([parent, groupOrders]) => {
          const firstOrder = groupOrders[0];
          const deadlineParts = firstOrder.deadline.split('/');
          const deadlineDate = new Date(
            parseInt(deadlineParts[2]),
            parseInt(deadlineParts[1]) - 1,
            parseInt(deadlineParts[0])
          );
          return { parent, orders: groupOrders, deadline: deadlineDate };
        })
        .sort((a, b) => a.deadline.getTime() - b.deadline.getTime());

      // Machine availability tracking (in hours)
      const machineAvailability = new Map<string, { hour: number; lastType: ProductType | null }>();
      machines.forEach((m) => {
        machineAvailability.set(m.name, { hour: 0, lastType: null });
      });

      const newOrders: SchedulerOrder[] = [];

      // Schedule each order group
      sortedGroups.forEach(({ orders: groupOrders }) => {
        const sortedOps = groupOrders.sort((a, b) => {
          // Sort by operation order (typical flow)
          const opOrder = ['Buigen', 'Zagen', 'Robotlassen', 'Handmatig lassen', 'Assemblage', 'Lektest'];
          return opOrder.indexOf(a.operation) - opOrder.indexOf(b.operation);
        });

        let prevOpEndHour = 0;

        sortedOps.forEach((order) => {
          // Fix: Check if machine exists in availability map
          if (!machineAvailability.has(order.machine)) {
            machineAvailability.set(order.machine, { hour: 0, lastType: null });
          }

          const availability = machineAvailability.get(order.machine)!;
          let startHour = Math.max(availability.hour, prevOpEndHour);

          // Add setup time if product type changes
          if (availability.lastType && availability.lastType !== order.productType) {
            const setupHours = getSetupTime(availability.lastType, order.productType);
            startHour += setupHours;
          }

          newOrders.push({
            ...order,
            startHour,
            status: order.status === 'locked' ? 'locked' : 'planned',
          });

          availability.hour = startHour + order.durationHours;
          availability.lastType = order.productType;
          prevOpEndHour = startHour + order.durationHours;
        });
      });

      return newOrders;
    });
  }, []);

  // Recalculate from selected order
  const handleRecalculate = useCallback((fromOrder: SchedulerOrder) => {
    setOrders((prev) => {
      const machineOrders = prev
        .filter((o) => o.machine === fromOrder.machine)
        .sort((a, b) => a.startHour - b.startHour);

      const fromIndex = machineOrders.findIndex((o) => o.id === fromOrder.id);
      if (fromIndex === -1) return prev;

      const ordersToRecalc = machineOrders.slice(fromIndex + 1);
      let currentHour = fromOrder.startHour + fromOrder.durationHours;
      let lastType = fromOrder.productType;

      const updates = new Map<string, number>();

      ordersToRecalc.forEach((order) => {
        if (lastType !== order.productType) {
          const setupHours = getSetupTime(lastType, order.productType);
          currentHour += setupHours;
        }

        updates.set(order.id, currentHour);
        currentHour += order.durationHours;
        lastType = order.productType;
      });

      return prev.map((o) => (updates.has(o.id) ? { ...o, startHour: updates.get(o.id)! } : o));
    });
  }, []);

  // Drag and drop handlers with hour precision
  const handleDragStart = useCallback(
    (e: React.DragEvent, order: SchedulerOrder) => {
      if (order.status === 'locked') {
        e.preventDefault();
        return;
      }
      setDraggedOrder(order);

      // Calculate offset from start of order block
      if (timelineRef.current) {
        const rect = timelineRef.current.getBoundingClientRect();
        const clickX = e.clientX - rect.left;
        const orderStartX = (order.startHour / hoursToShow) * rect.width;
        setDragOffset(clickX - orderStartX);
      }

      e.dataTransfer.effectAllowed = 'move';
    },
    [hoursToShow]
  );

  const handleDragOver = useCallback(
    (e: React.DragEvent, machine: string) => {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';

      // Calculate preview position
      if (draggedOrder && timelineRef.current && draggedOrder.machine === machine) {
        const rect = timelineRef.current.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const targetX = Math.max(0, mouseX - dragOffset);
        const newStartHour = Math.round((targetX / rect.width) * hoursToShow);

        setDragPreviewHour(newStartHour);
        setDragPreviewMachine(machine);
      }
    },
    [draggedOrder, dragOffset, hoursToShow]
  );

  const handleDrop = useCallback(
    (e: React.DragEvent, machine: string) => {
      e.preventDefault();
      if (!draggedOrder || !timelineRef.current) {
        setDraggedOrder(null);
        return;
      }

      // Can only drop on same machine
      if (draggedOrder.machine !== machine) {
        setDraggedOrder(null);
        return;
      }

      // Calculate new position from mouse X
      const rect = timelineRef.current.getBoundingClientRect();
      const mouseX = e.clientX - rect.left;
      const targetX = Math.max(0, mouseX - dragOffset);
      const newStartHour = Math.round((targetX / rect.width) * hoursToShow);

      setOrders((prev) => {
        const machineOrders = prev
          .filter((o) => o.machine === machine && o.id !== draggedOrder.id)
          .sort((a, b) => a.startHour - b.startHour);

        // Find where to insert
        const insertBeforeIndex = machineOrders.findIndex((o) => o.startHour > newStartHour);

        let finalStartHour = newStartHour;

        // Check for collision with previous order
        if (insertBeforeIndex > 0 || (insertBeforeIndex === -1 && machineOrders.length > 0)) {
          const prevOrder =
            insertBeforeIndex === -1
              ? machineOrders[machineOrders.length - 1]
              : machineOrders[insertBeforeIndex - 1];

          const minStart = prevOrder.startHour + prevOrder.durationHours;
          if (prevOrder.productType !== draggedOrder.productType) {
            const setupHours = getSetupTime(prevOrder.productType, draggedOrder.productType);
            finalStartHour = Math.max(finalStartHour, minStart + setupHours);
          } else {
            finalStartHour = Math.max(finalStartHour, minStart);
          }
        }

        // Update dragged order
        const updatedOrders = prev.map((o) =>
          o.id === draggedOrder.id ? { ...o, startHour: finalStartHour } : o
        );

        // Recalculate subsequent orders on same machine
        const sortedMachineOrders = updatedOrders
          .filter((o) => o.machine === machine)
          .sort((a, b) => a.startHour - b.startHour);

        const draggedIndex = sortedMachineOrders.findIndex((o) => o.id === draggedOrder.id);

        for (let i = draggedIndex + 1; i < sortedMachineOrders.length; i++) {
          const prevOrder = sortedMachineOrders[i - 1];
          const currentOrder = sortedMachineOrders[i];

          let minStartHour = prevOrder.startHour + prevOrder.durationHours;
          if (prevOrder.productType !== currentOrder.productType) {
            minStartHour += getSetupTime(prevOrder.productType, currentOrder.productType);
          }

          if (currentOrder.startHour < minStartHour) {
            currentOrder.startHour = minStartHour;
          }
        }

        return updatedOrders;
      });

      setDraggedOrder(null);
      setDragOffset(0);
      setDragPreviewHour(null);
      setDragPreviewMachine(null);
    },
    [draggedOrder, dragOffset, hoursToShow]
  );

  return (
    <div className="flex flex-col gap-4 h-[calc(100vh-7rem)]">
      {/* Filter bar */}
      <Card className="shrink-0">
        <CardContent className="py-3 px-4 space-y-3">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2 flex-wrap">
              {/* Multi-select machine groups */}
              <Popover>
                <PopoverTrigger asChild>
                  <Button variant="outline" className="h-8 w-36 justify-between text-xs">
                    {selectedGroups.length === 0
                      ? 'Alle Groepen'
                      : `${selectedGroups.length} geselecteerd`}
                    <ChevronsUpDown className="ml-2 h-3 w-3 shrink-0 opacity-50" />
                  </Button>
                </PopoverTrigger>
                <PopoverContent className="w-48 p-2" align="start">
                  <div className="space-y-1">
                    {machineGroups.map((group) => (
                      <div
                        key={group.id}
                        className="flex items-center space-x-2 rounded-sm px-2 py-1.5 text-sm cursor-pointer hover:bg-muted"
                        onClick={() => {
                          setSelectedGroups((prev) =>
                            prev.includes(group.id)
                              ? prev.filter((g) => g !== group.id)
                              : [...prev, group.id]
                          );
                        }}
                      >
                        <div
                          className={`h-4 w-4 rounded border flex items-center justify-center ${selectedGroups.includes(group.id)
                              ? 'bg-primary border-primary'
                              : 'border-input'
                            }`}
                        >
                          {selectedGroups.includes(group.id) && (
                            <Check className="h-3 w-3 text-primary-foreground" />
                          )}
                        </div>
                        <span>{group.name}</span>
                      </div>
                    ))}
                    {selectedGroups.length > 0 && (
                      <>
                        <Separator className="my-1" />
                        <Button
                          variant="ghost"
                          size="sm"
                          className="w-full h-7 text-xs"
                          onClick={() => setSelectedGroups([])}
                        >
                          Wis selectie
                        </Button>
                      </>
                    )}
                  </div>
                </PopoverContent>
              </Popover>
              <Select value={filterMachine} onValueChange={setFilterMachine}>
                <SelectTrigger className="h-8 w-36 text-xs">
                  <SelectValue placeholder="Machine" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all-machines">Alle Machines</SelectItem>
                  {availableMachinesForFilter.map((m) => (
                    <SelectItem key={m.name} value={m.name.toLowerCase().replace(/\s/g, '-')}>
                      {m.name}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
              <Input
                placeholder="Order #"
                className="h-8 w-32 text-xs"
                value={filterOrderNumber}
                onChange={(e) => setFilterOrderNumber(e.target.value)}
              />
              <Separator orientation="vertical" className="h-6" />
              <div className="flex items-center gap-1.5">
                <Switch
                  id="late"
                  checked={showLateOnly}
                  onCheckedChange={setShowLateOnly}
                  className="scale-75"
                />
                <Label htmlFor="late" className="text-xs cursor-pointer">
                  Alleen te laat
                </Label>
              </div>
            </div>

            <div className="flex items-center gap-2">
              <Separator orientation="vertical" className="h-6" />
              <div className="flex items-center gap-1">
                <Button
                  variant="outline"
                  size="sm"
                  className="h-8 w-8 p-0"
                  onClick={handleNavigateBackward}
                  disabled={!canNavigateBackward}
                  title="Vorige periode"
                >
                  <ChevronLeft className="h-4 w-4" />
                </Button>
                <Select
                  value={(hoursToShow / 24).toString()}
                  onValueChange={(v) => setHoursToShow(parseInt(v) * 24)}
                >
                  <SelectTrigger className="h-8 w-32 text-xs">
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="14">2 Weken</SelectItem>
                    <SelectItem value="28">4 Weken</SelectItem>
                    <SelectItem value="42">6 Weken</SelectItem>
                    <SelectItem value="56">8 Weken</SelectItem>
                  </SelectContent>
                </Select>
                <Button
                  variant="outline"
                  size="sm"
                  className="h-8 w-8 p-0"
                  onClick={handleNavigateForward}
                  title="Volgende periode"
                >
                  <ChevronRight className="h-4 w-4" />
                </Button>
              </div>
            </div>
          </div>

          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2">
              <Button
                variant="outline"
                size="sm"
                className="h-7 text-xs gap-1.5"
                onClick={() => selectedOrder && handlePurgeOrder(selectedOrder)}
                disabled={!selectedOrder || selectedOrder.status === 'locked'}
              >
                <PackageMinus className="h-3 w-3" />
                Opruimen
              </Button>
              <Button
                variant="outline"
                size="sm"
                className="h-7 text-xs gap-1.5"
                onClick={() => setPurgeAllDialogOpen(true)}
              >
                <PackageMinus className="h-3 w-3" />
                Alles Opruimen
              </Button>
              <Separator orientation="vertical" className="h-5" />
              <Button
                variant="outline"
                size="sm"
                className="h-7 text-xs gap-1.5"
                onClick={() => selectedOrder && handleToggleLock(selectedOrder)}
                disabled={!selectedOrder}
              >
                {selectedOrder?.status === 'locked' ? (
                  <>
                    <Unlock className="h-3 w-3" />
                    Ontgrendelen
                  </>
                ) : (
                  <>
                    <Lock className="h-3 w-3" />
                    Vergrendelen
                  </>
                )}
              </Button>
              <Button
                variant="outline"
                size="sm"
                className="h-7 text-xs gap-1.5 text-destructive"
                onClick={() => selectedOrder && handleDeleteOrder(selectedOrder)}
                disabled={!selectedOrder}
              >
                <Trash2 className="h-3 w-3" />
                Verwijderen
              </Button>
            </div>

            <div className="flex items-center gap-2">
              <Button
                variant="default"
                size="sm"
                className="h-7 text-xs gap-1.5"
                onClick={handleAutoPlan}
              >
                <Wand2 className="h-3 w-3" />
                Auto-plan
              </Button>
              <Button
                variant="outline"
                size="sm"
                className="h-7 text-xs gap-1.5"
                onClick={() => selectedOrder && handleRecalculate(selectedOrder)}
                disabled={!selectedOrder}
              >
                <RotateCcw className="h-3 w-3" />
                Herbereken
              </Button>
              <Separator orientation="vertical" className="h-5" />
              <Button
                variant={viewMode === 'gantt' ? 'default' : 'outline'}
                size="sm"
                className="h-7 text-xs gap-1.5"
                onClick={() => setViewMode('gantt')}
              >
                <LayoutGrid className="h-3 w-3" />
                Gantt
              </Button>
              <Button
                variant={viewMode === 'table' ? 'default' : 'outline'}
                size="sm"
                className="h-7 text-xs gap-1.5"
                onClick={() => setViewMode('table')}
              >
                <TableIcon className="h-3 w-3" />
                Tabel
              </Button>
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Main content area */}
      {viewMode === 'gantt' ? (
        <div className="flex gap-4 flex-1 min-h-0">
          {/* Gantt chart */}
          <Card className="flex-1 overflow-auto" ref={ganttChartRef}>
            <div className="min-w-[1200px]">
              {/* Timeline header */}
              <div className="border-b border-border sticky top-0 bg-card z-10">
                {timelineGroups.length > 0 ? (
                  // Two-row header for hourly view
                  <>
                    {/* Date group row */}
                    <div className="flex border-b border-border">
                      <div className="w-40 shrink-0 border-r border-border p-2 text-xs font-medium text-muted-foreground">
                        Machine
                      </div>
                      <div className="flex-1 flex" ref={timelineRef}>
                        {timelineGroups.map((group, groupIndex) => (
                          <div
                            key={`group-${groupIndex}`}
                            className={`flex-1 text-center text-xs py-1.5 border-r border-border font-semibold ${
                              group.isWeekend ? 'bg-muted/50' : ''
                            } ${groupIndex === 0 ? 'text-primary' : 'text-foreground'}`}
                            style={{
                              flexBasis: `${(group.columns.length / timelineColumns.length) * 100}%`,
                              flexGrow: group.columns.length,
                            }}
                          >
                            {group.dateLabel}
                          </div>
                        ))}
                      </div>
                    </div>
                    {/* Hour subdivisions row */}
                    <div className="flex">
                      <div className="w-40 shrink-0 border-r border-border"></div>
                      <div className="flex-1 flex">
                        {timelineColumns.map((col, index) => (
                          <div
                            key={`${col.hourOffset}-${index}`}
                            className={`flex-1 min-w-[32px] text-center text-[10px] py-1 border-r border-border ${
                              col.isWeekend ? 'bg-muted/50' : ''
                            } ${col.hourOffset === 0 ? 'font-bold text-primary' : 'text-muted-foreground'}`}
                          >
                            {col.label}
                          </div>
                        ))}
                      </div>
                    </div>
                  </>
                ) : (
                  // Single-row header for daily view
                  <div className="flex">
                    <div className="w-40 shrink-0 border-r border-border p-2 text-xs font-medium text-muted-foreground">
                      Machine
                    </div>
                    <div className="flex-1 flex" ref={timelineRef}>
                      {timelineColumns.map((col, index) => (
                        <div
                          key={`${col.hourOffset}-${index}`}
                          className={`flex-1 min-w-[32px] text-center text-[10px] py-1.5 border-r border-border ${
                            col.isWeekend ? 'bg-muted/50' : ''
                          } ${col.hourOffset === 0 ? 'font-bold text-primary' : 'text-muted-foreground'}`}
                        >
                          {col.label}
                        </div>
                      ))}
                    </div>
                  </div>
                )}
              </div>

              {/* Machine rows */}
              {filteredMachines.map((machine) => {
                const machineOrders = filteredOrders.filter((o) => o.machine === machine.name);
                const machineSetups = setupBlocks.filter(
                  (s) => s.machine === machine.name && s.startHour < hoursToShow
                );

                return (
                  <div
                    key={machine.name}
                    className="flex border-b border-border hover:bg-muted/20 gantt-timeline"
                    onDragOver={(e) => handleDragOver(e, machine.name)}
                    onDrop={(e) => handleDrop(e, machine.name)}
                  >
                    <div className="w-40 shrink-0 border-r border-border p-2 text-xs font-medium flex items-center">
                      {machine.name}
                      <span className="ml-1.5 text-[10px] text-muted-foreground">
                        ({machine.groupId})
                      </span>
                    </div>
                    <div className="flex-1 relative h-12">
                      {/* Weekend shading */}
                      {timelineColumns.map((col, index) =>
                        col.isWeekend ? (
                          <div
                            key={`weekend-${col.hourOffset}-${index}`}
                            className="absolute top-0 bottom-0 bg-muted/30 pointer-events-none"
                            style={{
                              left: `${(col.hourOffset / hoursToShow) * 100}%`,
                              width: `${((col.isHourly ? 1 : 24) / hoursToShow) * 100}%`,
                            }}
                          />
                        ) : null
                      )}
                      {/* Current time line (12 hours into timeline) */}
                      <div
                        className="absolute top-0 bottom-0 w-px bg-primary z-20 pointer-events-none"
                        style={{ left: `${(12 / hoursToShow) * 100}%` }}
                      />

                      {/* Setup blocks */}
                      {machineSetups.map((setup) => (
                        <Tooltip key={setup.id}>
                          <TooltipTrigger asChild>
                            <div
                              className="absolute top-7 h-4 bg-muted border border-border rounded-sm flex items-center justify-center text-[9px] text-muted-foreground pointer-events-none"
                              style={{
                                left: `${(setup.startHour / hoursToShow) * 100}%`,
                                width: `${(setup.durationHours / hoursToShow) * 100}%`,
                              }}
                            >
                              <span className="truncate px-1">Omstelling</span>
                            </div>
                          </TooltipTrigger>
                          <TooltipContent className="text-xs">
                            <p className="font-medium">Omstelling vereist</p>
                            <p>
                              Van {setup.fromType} → {setup.toType}
                            </p>
                            <p>{setup.setupHours.toFixed(1)} uur</p>
                          </TooltipContent>
                        </Tooltip>
                      ))}

                      {/* Order blocks */}
                      {machineOrders.map((order) => {
                        const isInSelectedFlow = orderFlow.some((o) => o.id === order.id);
                        const isSelected = selectedOrder?.id === order.id;
                        const isDimmed = selectedOrder && !isInSelectedFlow;
                        const isDragging = draggedOrder?.id === order.id;
                        
                        // Truncate order blocks that extend past visible timeline
                        const visibleDuration = Math.min(
                          order.durationHours,
                          hoursToShow - order.startHour
                        );

                        return (
                          <Tooltip key={order.id}>
                            <TooltipTrigger asChild>
                              <div
                                draggable={order.status !== 'locked'}
                                onDragStart={(e) => handleDragStart(e, order)}
                                onClick={() => setSelectedOrder(order)}
                                className={`absolute top-1 h-6 rounded ${statusColors[order.status]} text-white text-[10px] px-1.5 flex items-center gap-1 cursor-pointer hover:opacity-90 transition-all truncate ${isDimmed ? 'opacity-30' : ''
                                  } ${isSelected ? 'ring-2 ring-white ring-offset-1' : ''} ${isDragging ? 'opacity-50' : ''
                                  } ${order.status !== 'locked' ? 'cursor-move' : 'cursor-default'}`}
                                style={{
                                  left: `${(order.startHour / hoursToShow) * 100}%`,
                                  width: `${(visibleDuration / hoursToShow) * 100}%`,
                                  zIndex: isInSelectedFlow ? 15 : 10,
                                }}
                              >
                                {order.status === 'locked' && (
                                  <Lock className="h-2.5 w-2.5 shrink-0" />
                                )}
                                <span className="truncate font-medium">
                                  {order.orderNumber}
                                </span>
                              </div>
                            </TooltipTrigger>
                            <TooltipContent className="text-xs">
                              <p className="font-medium">
                                {order.orderNumber} — {order.operation}
                              </p>
                              <p>Type: {order.productType}</p>
                              <p>
                                {(order.durationHours / 8).toFixed(1)} dagen (
                                {order.durationHours}u) • Aantal: {order.quantity}
                              </p>
                              <p>Status: {statusLabels[order.status]}</p>
                              {order.status !== 'locked' && (
                                <p className="text-muted-foreground mt-1">
                                  Versleep om te verplaatsen
                                </p>
                              )}
                            </TooltipContent>
                          </Tooltip>
                        );
                      })}

                      {/* Drag preview */}
                      {dragPreviewHour !== null &&
                        dragPreviewMachine === machine.name &&
                        draggedOrder && (
                          <div
                            className="absolute top-1 h-6 rounded bg-primary/40 border-2 border-primary border-dashed pointer-events-none"
                            style={{
                              left: `${(dragPreviewHour / hoursToShow) * 100}%`,
                              width: `${(draggedOrder.durationHours / hoursToShow) * 100}%`,
                              zIndex: 20,
                            }}
                          />
                        )}
                    </div>
                  </div>
                );
              })}
            </div>
          </Card>

          {/* Right detail panel */}
          {selectedOrder && (
            <Card className="w-80 shrink-0 overflow-auto">
              <CardHeader className="pb-2 flex-row items-center justify-between">
                <CardTitle className="text-sm">Order Details</CardTitle>
                <Button
                  variant="ghost"
                  size="icon"
                  className="h-6 w-6"
                  onClick={() => setSelectedOrder(null)}
                >
                  <X className="h-3.5 w-3.5" />
                </Button>
              </CardHeader>
              <CardContent className="space-y-3 text-xs">
                <div className="space-y-1.5">
                  <div className="flex justify-between">
                    <span className="text-muted-foreground">Order</span>
                    <span className="font-medium">{selectedOrder.orderNumber}</span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-muted-foreground">Operatie</span>
                    <span>{selectedOrder.operation}</span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-muted-foreground">Producttype</span>
                    <Badge variant="outline" className="text-[10px]">
                      {selectedOrder.productType}
                    </Badge>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-muted-foreground">Aantal</span>
                    <span>{selectedOrder.quantity}</span>
                  </div>
                  <div className="flex justify-between items-center">
                    <span className="text-muted-foreground">Deadline</span>
                    <span className="flex items-center gap-1">
                      {selectedOrder.status === 'late' && (
                        <AlertTriangle className="h-3 w-3 text-status-danger" />
                      )}
                      {selectedOrder.deadline}
                    </span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-muted-foreground">Machine</span>
                    <span>{selectedOrder.machine}</span>
                  </div>
                  <div className="flex justify-between items-center">
                    <span className="text-muted-foreground">Materiaal</span>
                    <Badge
                      variant="outline"
                      className={`text-[10px] gap-1 ${selectedOrder.bomStatus === 'ok'
                          ? 'border-status-ok/30 text-status-ok'
                          : 'border-status-danger/30 text-status-danger'
                        }`}
                    >
                      {selectedOrder.bomStatus === 'ok' ? (
                        <>
                          <PackageCheck className="h-3 w-3" /> OK
                        </>
                      ) : (
                        <>
                          <PackageX className="h-3 w-3" /> Risico
                        </>
                      )}
                    </Badge>
                  </div>
                  <div className="space-y-1">
                    <span className="text-muted-foreground">Start Tijd (uren)</span>
                    <div className="flex gap-2 items-center">
                      <Input
                        type="number"
                        value={selectedOrder.startHour}
                        onChange={(e) => {
                          const newStartHour = Math.max(0, parseInt(e.target.value) || 0);
                          setOrders((prev) =>
                            prev.map((o) =>
                              o.id === selectedOrder.id
                                ? { ...o, startHour: newStartHour }
                                : o
                            )
                          );
                          setSelectedOrder((prev) =>
                            prev ? { ...prev, startHour: newStartHour } : null
                          );
                        }}
                        className="h-7 text-xs"
                        min={0}
                        step={1}
                      />
                      <span className="text-[10px] text-muted-foreground whitespace-nowrap">
                        {formatHourLabel(selectedOrder.startHour)}
                      </span>
                    </div>
                  </div>
                </div>

                <Separator />

                {/* Order flow info */}
                {orderFlow.length > 1 && (
                  <>
                    <div className="space-y-1.5">
                      <p className="text-muted-foreground font-medium">
                        Order Flow ({orderFlow.length} stappen)
                      </p>
                      <div className="space-y-1">
                        {orderFlow.map((op, idx) => (
                          <div
                            key={op.id}
                            className={`text-[11px] flex items-center gap-1.5 ${op.id === selectedOrder.id ? 'font-bold text-primary' : ''
                              }`}
                          >
                            <span className="text-muted-foreground">{idx + 1}.</span>
                            <span>{op.operation}</span>
                            <span className="text-muted-foreground">({op.machine})</span>
                          </div>
                        ))}
                      </div>
                    </div>
                    <Separator />
                  </>
                )}

                <div className="space-y-1.5">
                  <Button
                    variant="outline"
                    size="sm"
                    className="w-full h-7 text-xs gap-1.5 justify-start"
                    onClick={() => handleToggleLock(selectedOrder)}
                  >
                    {selectedOrder.status === 'locked' ? (
                      <>
                        <Unlock className="h-3 w-3" /> Ontgrendelen
                      </>
                    ) : (
                      <>
                        <Lock className="h-3 w-3" /> Vergrendelen
                      </>
                    )}
                  </Button>
                  <div className="grid grid-cols-2 gap-1.5">
                    <Button
                      variant="outline"
                      size="sm"
                      className="h-7 text-xs gap-1"
                      onClick={() => handleMoveOrder(selectedOrder, 'back')}
                    >
                      <ChevronLeft className="h-3 w-3" />
                      Terug
                    </Button>
                    <Button
                      variant="outline"
                      size="sm"
                      className="h-7 text-xs gap-1"
                      onClick={() => handleMoveOrder(selectedOrder, 'forward')}
                    >
                      Vooruit
                      <ChevronRight className="h-3 w-3" />
                    </Button>
                  </div>
                  <Button
                    variant="outline"
                    size="sm"
                    className="w-full h-7 text-xs gap-1.5 justify-start"
                    onClick={() => handlePurgeOrder(selectedOrder)}
                    disabled={selectedOrder.status === 'locked'}
                  >
                    <PackageMinus className="h-3 w-3" /> Opruimen
                  </Button>
                  <Button
                    variant="outline"
                    size="sm"
                    className="w-full h-7 text-xs gap-1.5 justify-start"
                    onClick={() => handleRecalculate(selectedOrder)}
                  >
                    <RotateCcw className="h-3 w-3" /> Herbereken vanaf hier
                  </Button>
                  <Button
                    variant="outline"
                    size="sm"
                    className="w-full h-7 text-xs gap-1.5 justify-start text-destructive"
                    onClick={() => handleDeleteOrder(selectedOrder)}
                  >
                    <Trash2 className="h-3 w-3" /> Verwijderen
                  </Button>
                </div>

                <Separator />

                {/* Validation warnings */}
                <div className="space-y-1.5">
                  {selectedOrder.status === 'late' && (
                    <div className="flex items-start gap-1.5 text-status-danger">
                      <AlertTriangle className="h-3 w-3 mt-0.5 shrink-0" />
                      <span>Deadline conflict — order is te laat</span>
                    </div>
                  )}
                  {selectedOrder.bomStatus === 'risk' && (
                    <div className="flex items-start gap-1.5 text-status-warning">
                      <AlertTriangle className="h-3 w-3 mt-0.5 shrink-0" />
                      <span>Mogelijk materiaaltekort</span>
                    </div>
                  )}
                  {selectedOrder.status !== 'late' && selectedOrder.bomStatus === 'ok' && (
                    <p className="text-muted-foreground">Geen problemen gedetecteerd.</p>
                  )}
                </div>
              </CardContent>
            </Card>
          )}
        </div>
      ) : (
        // Table view
        <Card className="flex-1 overflow-auto">
          <Table>
            <TableHeader>
              <TableRow>
                <TableHead className="w-32">Order</TableHead>
                <TableHead className="w-24">Type</TableHead>
                <TableHead>Operatie</TableHead>
                <TableHead className="w-36">Machine</TableHead>
                <TableHead className="w-24">Aantal</TableHead>
                <TableHead className="w-24">Duur</TableHead>
                <TableHead className="w-28">Start</TableHead>
                <TableHead className="w-28">Deadline</TableHead>
                <TableHead className="w-28">Status</TableHead>
                <TableHead className="w-24">Materiaal</TableHead>
              </TableRow>
            </TableHeader>
            <TableBody>
              {filteredOrders.map((order) => (
                <TableRow
                  key={order.id}
                  className="cursor-pointer hover:bg-muted/50"
                  onClick={() => setDrawerOrder(order)}
                >
                  <TableCell className="font-medium">{order.orderNumber}</TableCell>
                  <TableCell>
                    <Badge variant="outline" className="text-[10px]">
                      {order.productType}
                    </Badge>
                  </TableCell>
                  <TableCell>{order.operation}</TableCell>
                  <TableCell className="text-xs">{order.machine}</TableCell>
                  <TableCell>{order.quantity}</TableCell>
                  <TableCell>
                    {(order.durationHours / 8).toFixed(1)}d ({order.durationHours}u)
                  </TableCell>
                  <TableCell className="text-xs">{formatDate(startDate, order.startHour)}</TableCell>
                  <TableCell className="text-xs">{order.deadline}</TableCell>
                  <TableCell>
                    <Badge
                      variant="outline"
                      className={`text-[10px] ${statusColors[order.status]} text-white border-0`}
                    >
                      {statusLabels[order.status]}
                    </Badge>
                  </TableCell>
                  <TableCell>
                    {order.bomStatus === 'ok' ? (
                      <PackageCheck className="h-4 w-4 text-status-ok" />
                    ) : (
                      <PackageX className="h-4 w-4 text-status-danger" />
                    )}
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </Card>
      )}

      {/* Legend */}
      <div className="flex gap-4 text-xs text-muted-foreground shrink-0">
        {Object.entries(statusLabels).map(([k, v]) => (
          <div key={k} className="flex items-center gap-1.5">
            <span className={`h-2.5 w-2.5 rounded-sm ${statusColors[k]}`} />
            {v}
          </div>
        ))}
        <Separator orientation="vertical" className="h-4" />
        <div className="flex items-center gap-1.5">
          <span className="h-2.5 w-4 rounded-sm bg-muted border border-border" />
          Omstelling
        </div>
      </div>

      {/* Table view detail drawer */}
      <Sheet open={!!drawerOrder} onOpenChange={(open) => !open && setDrawerOrder(null)}>
        <SheetContent>
          <SheetHeader>
            <SheetTitle>Order Details</SheetTitle>
          </SheetHeader>
          {drawerOrder && (
            <div className="mt-6 space-y-4 text-sm">
              <div className="space-y-2">
                <div className="flex justify-between">
                  <span className="text-muted-foreground">Order</span>
                  <span className="font-medium">{drawerOrder.orderNumber}</span>
                </div>
                <div className="flex justify-between">
                  <span className="text-muted-foreground">Operatie</span>
                  <span>{drawerOrder.operation}</span>
                </div>
                <div className="flex justify-between">
                  <span className="text-muted-foreground">Producttype</span>
                  <Badge variant="outline">{drawerOrder.productType}</Badge>
                </div>
                <div className="flex justify-between">
                  <span className="text-muted-foreground">Aantal</span>
                  <span>{drawerOrder.quantity}</span>
                </div>
                <div className="flex justify-between">
                  <span className="text-muted-foreground">Duur</span>
                  <span>
                    {(drawerOrder.durationHours / 8).toFixed(1)} dagen ({drawerOrder.durationHours}{' '}
                    uur)
                  </span>
                </div>
                <div className="flex justify-between">
                  <span className="text-muted-foreground">Start</span>
                  <span>{formatDate(startDate, drawerOrder.startHour)}</span>
                </div>
                <div className="flex justify-between items-center">
                  <span className="text-muted-foreground">Deadline</span>
                  <span className="flex items-center gap-1">
                    {drawerOrder.status === 'late' && (
                      <AlertTriangle className="h-4 w-4 text-status-danger" />
                    )}
                    {drawerOrder.deadline}
                  </span>
                </div>
                <div className="flex justify-between">
                  <span className="text-muted-foreground">Machine</span>
                  <span>{drawerOrder.machine}</span>
                </div>
                <div className="flex justify-between items-center">
                  <span className="text-muted-foreground">Status</span>
                  <Badge
                    variant="outline"
                    className={`${statusColors[drawerOrder.status]} text-white border-0`}
                  >
                    {statusLabels[drawerOrder.status]}
                  </Badge>
                </div>
                <div className="flex justify-between items-center">
                  <span className="text-muted-foreground">Materiaal</span>
                  <Badge
                    variant="outline"
                    className={`gap-1 ${drawerOrder.bomStatus === 'ok'
                        ? 'border-status-ok/30 text-status-ok'
                        : 'border-status-danger/30 text-status-danger'
                      }`}
                  >
                    {drawerOrder.bomStatus === 'ok' ? (
                      <>
                        <PackageCheck className="h-4 w-4" /> OK
                      </>
                    ) : (
                      <>
                        <PackageX className="h-4 w-4" /> Risico
                      </>
                    )}
                  </Badge>
                </div>
              </div>

              <Separator />

              {/* Order flow info in drawer */}
              {drawerOrder.parentOrderNumber && (
                <>
                  <div className="space-y-2">
                    <p className="text-muted-foreground font-medium">Order Flow</p>
                    <div className="space-y-1.5">
                      {orders
                        .filter((o) => o.parentOrderNumber === drawerOrder.parentOrderNumber)
                        .sort((a, b) => a.startHour - b.startHour)
                        .map((op, idx) => (
                          <div
                            key={op.id}
                            className={`text-sm flex items-center gap-2 ${op.id === drawerOrder.id ? 'font-bold text-primary' : ''
                              }`}
                          >
                            <span className="text-muted-foreground">{idx + 1}.</span>
                            <span>{op.operation}</span>
                            <span className="text-muted-foreground text-xs">
                              ({op.machine})
                            </span>
                          </div>
                        ))}
                    </div>
                  </div>
                  <Separator />
                </>
              )}

              <div className="space-y-2">
                <Button
                  variant="outline"
                  size="sm"
                  className="w-full gap-2"
                  onClick={() => {
                    handleToggleLock(drawerOrder);
                    setDrawerOrder((prev) =>
                      prev
                        ? { ...prev, status: prev.status === 'locked' ? 'planned' : 'locked' }
                        : null
                    );
                  }}
                >
                  {drawerOrder.status === 'locked' ? (
                    <>
                      <Unlock className="h-4 w-4" /> Ontgrendelen
                    </>
                  ) : (
                    <>
                      <Lock className="h-4 w-4" /> Vergrendelen
                    </>
                  )}
                </Button>
                <div className="grid grid-cols-2 gap-2">
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => handleMoveOrder(drawerOrder, 'back')}
                  >
                    <ChevronLeft className="h-4 w-4 mr-1" />
                    Terug
                  </Button>
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => handleMoveOrder(drawerOrder, 'forward')}
                  >
                    Vooruit
                    <ChevronRight className="h-4 w-4 ml-1" />
                  </Button>
                </div>
                <Button
                  variant="outline"
                  size="sm"
                  className="w-full gap-2"
                  onClick={() => handlePurgeOrder(drawerOrder)}
                  disabled={drawerOrder.status === 'locked'}
                >
                  <PackageMinus className="h-4 w-4" /> Opruimen
                </Button>
                <Button
                  variant="outline"
                  size="sm"
                  className="w-full gap-2"
                  onClick={() => handleRecalculate(drawerOrder)}
                >
                  <RotateCcw className="h-4 w-4" /> Herbereken vanaf hier
                </Button>
                <Button
                  variant="outline"
                  size="sm"
                  className="w-full gap-2 text-destructive"
                  onClick={() => {
                    handleDeleteOrder(drawerOrder);
                    setDrawerOrder(null);
                  }}
                >
                  <Trash2 className="h-4 w-4" /> Verwijderen
                </Button>
              </div>

              <Separator />

              {/* Validation warnings in drawer */}
              <div className="space-y-2">
                {drawerOrder.status === 'late' && (
                  <div className="flex items-start gap-2 text-status-danger text-sm">
                    <AlertTriangle className="h-4 w-4 mt-0.5 shrink-0" />
                    <span>Deadline conflict — order is te laat</span>
                  </div>
                )}
                {drawerOrder.bomStatus === 'risk' && (
                  <div className="flex items-start gap-2 text-status-warning text-sm">
                    <AlertTriangle className="h-4 w-4 mt-0.5 shrink-0" />
                    <span>Mogelijk materiaaltekort</span>
                  </div>
                )}
                {drawerOrder.status !== 'late' && drawerOrder.bomStatus === 'ok' && (
                  <p className="text-muted-foreground text-sm">Geen problemen gedetecteerd.</p>
                )}
              </div>
            </div>
          )}
        </SheetContent>
      </Sheet>

      {/* Purge All Dialog */}
      <Dialog open={purgeAllDialogOpen} onOpenChange={setPurgeAllDialogOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Alles Opruimen</DialogTitle>
            <DialogDescription>
              Selecteer machines en tijdsperiode om alle orders op te ruimen (niet-vergrendelde orders
              worden zo dicht mogelijk ingepland).
            </DialogDescription>
          </DialogHeader>
          <div className="space-y-4 py-4">
            <div className="space-y-2">
              <Label>Machines</Label>
              <div className="grid grid-cols-2 gap-2 max-h-48 overflow-auto border rounded-md p-3">
                {machines.map((machine) => (
                  <div key={machine.name} className="flex items-center space-x-2">
                    <Checkbox
                      id={`machine-${machine.name}`}
                      checked={selectedMachines.includes(machine.name)}
                      onCheckedChange={(checked) => {
                        if (checked) {
                          setSelectedMachines((prev) => [...prev, machine.name]);
                        } else {
                          setSelectedMachines((prev) =>
                            prev.filter((m) => m !== machine.name)
                          );
                        }
                      }}
                    />
                    <Label htmlFor={`machine-${machine.name}`} className="text-xs cursor-pointer">
                      {machine.name}
                    </Label>
                  </div>
                ))}
              </div>
            </div>
            <div className="grid grid-cols-2 gap-4">
              <div className="space-y-2">
                <Label htmlFor="purge-start-date">Startdatum</Label>
                <Input
                  id="purge-start-date"
                  type="date"
                  value={purgeStartDate}
                  onChange={(e) => setPurgeStartDate(e.target.value)}
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="purge-start-time">Starttijd</Label>
                <Input
                  id="purge-start-time"
                  type="time"
                  value={purgeStartTime}
                  onChange={(e) => setPurgeStartTime(e.target.value)}
                />
              </div>
            </div>
            <div className="grid grid-cols-2 gap-4">
              <div className="space-y-2">
                <Label htmlFor="purge-end-date">Einddatum</Label>
                <Input
                  id="purge-end-date"
                  type="date"
                  value={purgeEndDate}
                  onChange={(e) => setPurgeEndDate(e.target.value)}
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="purge-end-time">Eindtijd</Label>
                <Input
                  id="purge-end-time"
                  type="time"
                  value={purgeEndTime}
                  onChange={(e) => setPurgeEndTime(e.target.value)}
                />
              </div>
            </div>
          </div>
          <DialogFooter>
            <Button variant="outline" onClick={() => setPurgeAllDialogOpen(false)}>
              Annuleren
            </Button>
            <Button onClick={handlePurgeAll} disabled={selectedMachines.length === 0}>
              Opruimen
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );
}
